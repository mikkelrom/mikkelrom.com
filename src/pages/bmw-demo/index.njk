---
permalink: /bmw-demo/
eleventyExcludeFromCollections: true
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BMW Vision EV — Interactive 3D Experience</title>
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    #canvas-container {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0;
    }

    canvas { display: block; }

    /* Loading screen */
    #loader {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.8s ease, visibility 0.8s ease;
    }
    #loader.hidden {
      opacity: 0;
      visibility: hidden;
    }
    #loader .logo-text {
      font-size: 2.5rem;
      font-weight: 700;
      letter-spacing: 0.3em;
      margin-bottom: 2rem;
      background: linear-gradient(135deg, #fff 0%, #999 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    #loader .progress-bar {
      width: 200px;
      height: 2px;
      background: #222;
      border-radius: 1px;
      overflow: hidden;
    }
    #loader .progress-fill {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #1e88e5, #42a5f5);
      transition: width 0.3s ease;
      animation: loading 2s ease-in-out infinite;
    }
    @keyframes loading {
      0% { width: 0%; margin-left: 0; }
      50% { width: 60%; margin-left: 20%; }
      100% { width: 0%; margin-left: 100%; }
    }

    /* Top bar */
    #top-bar {
      position: fixed;
      top: 0; left: 0; right: 0;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 2rem;
      z-index: 100;
      background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, transparent 100%);
    }
    #top-bar a {
      color: #fff;
      text-decoration: none;
      font-size: 0.8rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      opacity: 0.7;
      transition: opacity 0.3s;
    }
    #top-bar a:hover { opacity: 1; }
    #top-bar .brand {
      font-size: 1.1rem;
      font-weight: 700;
      letter-spacing: 0.3em;
      opacity: 1;
    }

    /* Info panel */
    #info-panel {
      position: fixed;
      bottom: 2rem;
      left: 2rem;
      z-index: 100;
      max-width: 380px;
    }
    #info-panel h1 {
      font-size: 2rem;
      font-weight: 300;
      letter-spacing: 0.05em;
      line-height: 1.2;
      margin-bottom: 0.5rem;
    }
    #info-panel h1 span {
      font-weight: 700;
    }
    #info-panel .subtitle {
      font-size: 0.75rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: #42a5f5;
      margin-bottom: 1rem;
    }
    #info-panel .specs {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
      margin-top: 1rem;
    }
    #info-panel .spec-item .value {
      font-size: 1.4rem;
      font-weight: 600;
    }
    #info-panel .spec-item .label {
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #888;
      margin-top: 0.15rem;
    }

    /* Controls panel */
    #controls-panel {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 1rem;
    }

    .color-options {
      display: flex;
      gap: 0.5rem;
    }
    .color-swatch {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: border-color 0.3s, transform 0.2s;
      position: relative;
    }
    .color-swatch:hover { transform: scale(1.15); }
    .color-swatch.active { border-color: #fff; }

    .btn-group {
      display: flex;
      gap: 0.5rem;
    }
    .btn {
      padding: 0.5rem 1rem;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.05);
      color: #fff;
      font-size: 0.7rem;
      font-family: inherit;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.3s;
      backdrop-filter: blur(10px);
    }
    .btn:hover {
      background: rgba(255,255,255,0.15);
      border-color: rgba(255,255,255,0.4);
    }
    .btn.active {
      background: rgba(255,255,255,0.2);
      border-color: #42a5f5;
    }

    /* Hint text */
    #hint {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.65rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: #555;
      z-index: 100;
      transition: opacity 1s;
    }

    /* Responsive */
    @media (max-width: 768px) {
      #info-panel { left: 1rem; bottom: 8rem; max-width: 280px; }
      #info-panel h1 { font-size: 1.4rem; }
      #info-panel .specs { gap: 0.6rem; }
      #info-panel .spec-item .value { font-size: 1.1rem; }
      #controls-panel { bottom: 1.5rem; right: 1rem; }
      #top-bar { padding: 0 1rem; }
    }
  </style>
</head>
<body>

  <!-- Loading screen -->
  <div id="loader">
    <div class="logo-text">BMW</div>
    <div class="progress-bar"><div class="progress-fill"></div></div>
  </div>

  <!-- Top bar -->
  <div id="top-bar">
    <a href="/" class="brand">BMW</a>
    <a href="/">← Back to site</a>
  </div>

  <!-- 3D Canvas -->
  <div id="canvas-container"></div>

  <!-- Info panel -->
  <div id="info-panel">
    <div class="subtitle">All-Electric Gran Coupé</div>
    <h1>BMW <span>Vision EV</span></h1>
    <div class="specs">
      <div class="spec-item">
        <div class="value">523</div>
        <div class="label">HP Power</div>
      </div>
      <div class="spec-item">
        <div class="value">3.8s</div>
        <div class="label">0–100 km/h</div>
      </div>
      <div class="spec-item">
        <div class="value">625</div>
        <div class="label">km Range</div>
      </div>
    </div>
  </div>

  <!-- Controls -->
  <div id="controls-panel">
    <div class="color-options">
      <div class="color-swatch active" data-color="0x1a1a2e" style="background:#1a1a2e" title="Tanzanite Blue"></div>
      <div class="color-swatch" data-color="0x8b0000" style="background:#8b0000" title="Melbourne Red"></div>
      <div class="color-swatch" data-color="0xf5f5f5" style="background:#f5f5f5" title="Alpine White"></div>
      <div class="color-swatch" data-color="0x1c1c1c" style="background:#1c1c1c" title="Black Sapphire"></div>
      <div class="color-swatch" data-color="0x2d4a3e" style="background:#2d4a3e" title="British Racing Green"></div>
    </div>
    <div class="btn-group">
      <button class="btn active" data-view="orbit" id="btn-orbit">Orbit</button>
      <button class="btn" data-view="front" id="btn-front">Front</button>
      <button class="btn" data-view="side" id="btn-side">Side</button>
      <button class="btn" data-view="rear" id="btn-rear">Rear</button>
    </div>
  </div>

  <div id="hint">Drag to rotate · Scroll to zoom</div>

  <!-- Three.js -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ─── SCENE SETUP ─────────────────────────────────────
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(6, 3, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2.05;
    controls.minDistance = 5;
    controls.maxDistance = 20;
    controls.target.set(0, 0.8, 0);

    // ─── ENVIRONMENT ─────────────────────────────────────
    function createEnvironment() {
      // Gradient background
      const bgCanvas = document.createElement('canvas');
      bgCanvas.width = 2;
      bgCanvas.height = 512;
      const ctx = bgCanvas.getContext('2d');
      const grad = ctx.createLinearGradient(0, 0, 0, 512);
      grad.addColorStop(0, '#1a1a2e');
      grad.addColorStop(0.5, '#16213e');
      grad.addColorStop(1, '#0a0a0a');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 2, 512);
      const bgTexture = new THREE.CanvasTexture(bgCanvas);
      scene.background = bgTexture;

      // Environment map for reflections
      const envScene = new THREE.Scene();
      const envCamera = new THREE.CubeCamera(0.1, 100, new THREE.WebGLCubeRenderTarget(256, {
        format: THREE.RGBAFormat,
        generateMipmaps: true,
        minFilter: THREE.LinearMipmapLinearFilter
      }));

      // Create a colored box for env reflections
      const envGeo = new THREE.SphereGeometry(50, 32, 32);
      const envMat = new THREE.MeshBasicMaterial({
        side: THREE.BackSide,
        color: 0x111122
      });
      const envMesh = new THREE.Mesh(envGeo, envMat);
      envScene.add(envMesh);

      // Add some bright spots for reflections
      const lightGeo = new THREE.PlaneGeometry(20, 5);
      const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
      const lightPanel1 = new THREE.Mesh(lightGeo, lightMat);
      lightPanel1.position.set(0, 10, 0);
      lightPanel1.rotation.x = Math.PI / 2;
      envScene.add(lightPanel1);

      const lightPanel2 = new THREE.Mesh(lightGeo.clone(), lightMat.clone());
      lightPanel2.position.set(10, 5, 0);
      lightPanel2.rotation.y = -Math.PI / 2;
      envScene.add(lightPanel2);

      const lightPanel3 = new THREE.Mesh(lightGeo.clone(), lightMat.clone());
      lightPanel3.position.set(-10, 5, 0);
      lightPanel3.rotation.y = Math.PI / 2;
      envScene.add(lightPanel3);

      envCamera.position.set(0, 1, 0);
      envCamera.update(renderer, envScene);

      return envCamera.renderTarget.texture;
    }

    const envMap = createEnvironment();

    // ─── GROUND PLANE ────────────────────────────────────
    function createGround() {
      const groundGeo = new THREE.CircleGeometry(30, 64);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x080808,
        metalness: 0.8,
        roughness: 0.3,
        envMap: envMap,
        envMapIntensity: 0.5
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.01;
      ground.receiveShadow = true;
      scene.add(ground);

      // Subtle ring detail
      const ringGeo = new THREE.RingGeometry(4, 4.05, 64);
      const ringMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2a, side: THREE.DoubleSide });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = -Math.PI / 2;
      ring.position.y = 0.001;
      scene.add(ring);
    }
    createGround();

    // ─── MATERIALS ───────────────────────────────────────
    let bodyColor = new THREE.Color(0x1a1a2e);

    const bodyMaterial = new THREE.MeshPhysicalMaterial({
      color: bodyColor,
      metalness: 0.9,
      roughness: 0.15,
      clearcoat: 1.0,
      clearcoatRoughness: 0.05,
      envMap: envMap,
      envMapIntensity: 1.5
    });

    const darkTrimMaterial = new THREE.MeshPhysicalMaterial({
      color: 0x0a0a0a,
      metalness: 0.5,
      roughness: 0.2,
      clearcoat: 0.8,
      envMap: envMap,
      envMapIntensity: 1.0
    });

    const chromeMaterial = new THREE.MeshStandardMaterial({
      color: 0xcccccc,
      metalness: 1.0,
      roughness: 0.05,
      envMap: envMap,
      envMapIntensity: 2.0
    });

    const glassMaterial = new THREE.MeshPhysicalMaterial({
      color: 0x111122,
      metalness: 0.1,
      roughness: 0.0,
      transmission: 0.9,
      thickness: 0.5,
      envMap: envMap,
      envMapIntensity: 0.5,
      transparent: true,
      opacity: 0.3
    });

    const headlightMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xaaddff,
      emissiveIntensity: 2.0,
      metalness: 0.0,
      roughness: 0.0
    });

    const taillightMaterial = new THREE.MeshStandardMaterial({
      color: 0xff0000,
      emissive: 0xff2222,
      emissiveIntensity: 1.5,
      metalness: 0.0,
      roughness: 0.1
    });

    const tireMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a1a1a,
      metalness: 0.0,
      roughness: 0.9
    });

    const rimMaterial = new THREE.MeshStandardMaterial({
      color: 0x888888,
      metalness: 0.95,
      roughness: 0.1,
      envMap: envMap,
      envMapIntensity: 1.5
    });

    const bluAccentMaterial = new THREE.MeshStandardMaterial({
      color: 0x1e88e5,
      emissive: 0x1565c0,
      emissiveIntensity: 0.5,
      metalness: 0.3,
      roughness: 0.3
    });

    // ─── CAR GROUP ───────────────────────────────────────
    const carGroup = new THREE.Group();
    scene.add(carGroup);

    // Helper function for rounded box shapes
    function createRoundedBox(w, h, d, r, s) {
      const shape = new THREE.Shape();
      const x = -w / 2, y = -h / 2;
      shape.moveTo(x + r, y);
      shape.lineTo(x + w - r, y);
      shape.quadraticCurveTo(x + w, y, x + w, y + r);
      shape.lineTo(x + w, y + h - r);
      shape.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      shape.lineTo(x + r, y + h);
      shape.quadraticCurveTo(x, y + h, x, y + h - r);
      shape.lineTo(x, y + r);
      shape.quadraticCurveTo(x, y, x + r, y);

      const extrudeSettings = { depth: d, bevelEnabled: true, bevelThickness: r * 0.5, bevelSize: r * 0.5, bevelSegments: s || 4 };
      const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geo.translate(0, 0, -d / 2);
      return geo;
    }

    function buildCar() {
      // ── LOWER BODY ──
      const lowerBodyGeo = createRoundedBox(4.8, 0.8, 2.0, 0.15, 4);
      const lowerBody = new THREE.Mesh(lowerBodyGeo, bodyMaterial);
      lowerBody.position.set(0, 0.45, 0);
      lowerBody.castShadow = true;
      carGroup.add(lowerBody);

      // ── UPPER BODY (Hood + Trunk area) ──
      const upperShape = new THREE.Shape();
      // Side profile of the upper body
      upperShape.moveTo(-2.2, 0);
      upperShape.lineTo(-1.8, 0);
      upperShape.lineTo(-1.6, 0.35); // windshield start
      upperShape.bezierCurveTo(-1.3, 0.7, -0.5, 0.8, 0, 0.82);
      upperShape.bezierCurveTo(0.5, 0.8, 1.0, 0.75, 1.3, 0.55);
      upperShape.lineTo(1.6, 0.3);  // rear window end
      upperShape.lineTo(2.0, 0.15);
      upperShape.lineTo(2.2, 0);
      upperShape.lineTo(-2.2, 0);

      const upperExtrudeSettings = { depth: 1.7, bevelEnabled: true, bevelThickness: 0.08, bevelSize: 0.08, bevelSegments: 3 };
      const upperBodyGeo = new THREE.ExtrudeGeometry(upperShape, upperExtrudeSettings);
      upperBodyGeo.translate(0, 0, -0.85);
      const upperBody = new THREE.Mesh(upperBodyGeo, bodyMaterial);
      upperBody.position.set(0, 0.85, 0);
      upperBody.castShadow = true;
      carGroup.add(upperBody);

      // ── CABIN / GREENHOUSE (Glass) ──
      const cabinShape = new THREE.Shape();
      cabinShape.moveTo(-1.55, 0.02);
      cabinShape.lineTo(-1.35, 0.3);
      cabinShape.bezierCurveTo(-1.1, 0.58, -0.4, 0.65, 0, 0.67);
      cabinShape.bezierCurveTo(0.4, 0.65, 0.8, 0.55, 1.1, 0.4);
      cabinShape.lineTo(1.35, 0.18);
      cabinShape.lineTo(1.5, 0.02);
      cabinShape.lineTo(-1.55, 0.02);

      const cabinExtrudeSettings = { depth: 1.5, bevelEnabled: true, bevelThickness: 0.03, bevelSize: 0.03, bevelSegments: 2 };
      const cabinGeo = new THREE.ExtrudeGeometry(cabinShape, cabinExtrudeSettings);
      cabinGeo.translate(0, 0, -0.75);
      const cabin = new THREE.Mesh(cabinGeo, glassMaterial);
      cabin.position.set(0, 0.88, 0);
      carGroup.add(cabin);

      // ── WINDOW PILLARS (A, B, C pillars) ──
      const pillarMat = darkTrimMaterial;
      const pillarGeo = new THREE.BoxGeometry(0.06, 0.5, 0.06);

      // A-pillars (front)
      [-0.72, 0.72].forEach(z => {
        const aPillar = new THREE.Mesh(pillarGeo, pillarMat);
        aPillar.position.set(-1.4, 1.15, z);
        aPillar.rotation.z = 0.4;
        carGroup.add(aPillar);
      });

      // B-pillars (middle)
      [-0.72, 0.72].forEach(z => {
        const bPillar = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.45, 0.06), pillarMat);
        bPillar.position.set(-0.2, 1.15, z);
        carGroup.add(bPillar);
      });

      // C-pillars (rear)
      [-0.68, 0.68].forEach(z => {
        const cPillar = new THREE.Mesh(pillarGeo, pillarMat);
        cPillar.position.set(1.15, 1.1, z);
        cPillar.rotation.z = -0.35;
        carGroup.add(cPillar);
      });

      // ── HOOD CHARACTER LINE ──
      const hoodLineGeo = new THREE.BoxGeometry(1.5, 0.01, 0.01);
      const hoodLine = new THREE.Mesh(hoodLineGeo, chromeMaterial);
      hoodLine.position.set(-1.9, 0.92, 0);
      hoodLine.rotation.z = 0.05;
      carGroup.add(hoodLine);

      // ── BMW KIDNEY GRILLE ──
      function createKidneyGrille(offsetZ) {
        const grillGroup = new THREE.Group();

        // Grille outline
        const outlineShape = new THREE.Shape();
        outlineShape.moveTo(0, -0.15);
        outlineShape.bezierCurveTo(0.18, -0.15, 0.22, -0.1, 0.22, 0);
        outlineShape.bezierCurveTo(0.22, 0.1, 0.18, 0.2, 0, 0.2);
        outlineShape.bezierCurveTo(-0.18, 0.2, -0.22, 0.1, -0.22, 0);
        outlineShape.bezierCurveTo(-0.22, -0.1, -0.18, -0.15, 0, -0.15);

        const grillGeo = new THREE.ExtrudeGeometry(outlineShape, { depth: 0.05, bevelEnabled: false });
        const grillMesh = new THREE.Mesh(grillGeo, darkTrimMaterial);
        grillMesh.rotation.y = Math.PI / 2;
        grillGroup.add(grillMesh);

        // Chrome surround
        const surroundGeo = new THREE.TorusGeometry(0.19, 0.012, 8, 32);
        const surround = new THREE.Mesh(surroundGeo, chromeMaterial);
        surround.position.x = -0.03;
        surround.rotation.y = Math.PI / 2;
        surround.position.y = 0.025;
        grillGroup.add(surround);

        // Vertical slats
        for (let i = -3; i <= 3; i++) {
          const slatGeo = new THREE.BoxGeometry(0.06, 0.3, 0.008);
          const slat = new THREE.Mesh(slatGeo, chromeMaterial);
          slat.position.set(-0.02, 0.025, i * 0.05);
          grillGroup.add(slat);
        }

        // Blue accent (BMW i)
        const accentGeo = new THREE.BoxGeometry(0.01, 0.35, 0.01);
        const accent = new THREE.Mesh(accentGeo, bluAccentMaterial);
        accent.position.set(-0.04, 0.025, 0);
        grillGroup.add(accent);

        grillGroup.position.set(-2.55, 0.65, offsetZ);
        return grillGroup;
      }

      carGroup.add(createKidneyGrille(0.15));
      carGroup.add(createKidneyGrille(-0.15));

      // ── HEADLIGHTS ──
      function createHeadlight(z) {
        const hlGroup = new THREE.Group();

        // Main light housing
        const housingGeo = new THREE.BoxGeometry(0.15, 0.08, 0.35);
        const housing = new THREE.Mesh(housingGeo, darkTrimMaterial);
        hlGroup.add(housing);

        // LED strip (angular BMW style)
        const ledShape = new THREE.Shape();
        ledShape.moveTo(-0.15, 0);
        ledShape.lineTo(0.15, 0);
        ledShape.lineTo(0.12, 0.03);
        ledShape.lineTo(-0.12, 0.03);
        const ledGeo = new THREE.ExtrudeGeometry(ledShape, { depth: 0.02, bevelEnabled: false });
        const led = new THREE.Mesh(ledGeo, headlightMaterial);
        led.position.set(0, -0.01, -0.01);
        led.rotation.y = Math.PI / 2;
        hlGroup.add(led);

        // DRL angel eye (BMW signature)
        const angelGeo = new THREE.TorusGeometry(0.06, 0.008, 8, 32, Math.PI * 1.5);
        const angel = new THREE.Mesh(angelGeo, headlightMaterial);
        angel.rotation.y = Math.PI / 2;
        angel.position.x = 0.01;
        hlGroup.add(angel);

        // Point light from headlight
        const hlLight = new THREE.PointLight(0xaaddff, 0.5, 5);
        hlLight.position.set(-0.2, 0, 0);
        hlGroup.add(hlLight);

        hlGroup.position.set(-2.52, 0.68, z);
        return hlGroup;
      }

      carGroup.add(createHeadlight(0.7));
      carGroup.add(createHeadlight(-0.7));

      // ── TAIL LIGHTS ──
      function createTaillight(z) {
        const tlGroup = new THREE.Group();

        // Housing
        const housingGeo = new THREE.BoxGeometry(0.12, 0.12, 0.5);
        const housing = new THREE.Mesh(housingGeo, darkTrimMaterial);
        tlGroup.add(housing);

        // LED bar
        const ledGeo = new THREE.BoxGeometry(0.02, 0.06, 0.45);
        const led = new THREE.Mesh(ledGeo, taillightMaterial);
        led.position.x = 0.06;
        tlGroup.add(led);

        tlGroup.position.set(2.45, 0.75, z);
        return tlGroup;
      }

      carGroup.add(createTaillight(0.6));
      carGroup.add(createTaillight(-0.6));

      // Tail light connecting bar (BMW style)
      const tailBarGeo = new THREE.BoxGeometry(0.02, 0.025, 1.0);
      const tailBar = new THREE.Mesh(tailBarGeo, taillightMaterial);
      tailBar.position.set(2.52, 0.75, 0);
      carGroup.add(tailBar);

      // ── SIDE SKIRTS ──
      [-0.95, 0.95].forEach(z => {
        const skirtGeo = new THREE.BoxGeometry(3.2, 0.08, 0.03);
        const skirt = new THREE.Mesh(skirtGeo, darkTrimMaterial);
        skirt.position.set(0, 0.12, z);
        carGroup.add(skirt);

        // Blue accent line
        const accentGeo = new THREE.BoxGeometry(2.0, 0.015, 0.015);
        const accent = new THREE.Mesh(accentGeo, bluAccentMaterial);
        accent.position.set(-0.2, 0.15, z * 1.02);
        carGroup.add(accent);
      });

      // ── FRONT BUMPER / SPLITTER ──
      const splitterGeo = new THREE.BoxGeometry(0.06, 0.04, 2.0);
      const splitter = new THREE.Mesh(splitterGeo, darkTrimMaterial);
      splitter.position.set(-2.55, 0.15, 0);
      carGroup.add(splitter);

      // Air intakes
      [-0.55, 0.55].forEach(z => {
        const intakeGeo = new THREE.BoxGeometry(0.08, 0.15, 0.4);
        const intake = new THREE.Mesh(intakeGeo, darkTrimMaterial);
        intake.position.set(-2.5, 0.3, z);
        carGroup.add(intake);
      });

      // ── REAR DIFFUSER ──
      const diffuserGeo = new THREE.BoxGeometry(0.08, 0.12, 1.8);
      const diffuser = new THREE.Mesh(diffuserGeo, darkTrimMaterial);
      diffuser.position.set(2.48, 0.18, 0);
      carGroup.add(diffuser);

      // Diffuser fins
      for (let i = -3; i <= 3; i++) {
        const finGeo = new THREE.BoxGeometry(0.12, 0.1, 0.015);
        const fin = new THREE.Mesh(finGeo, darkTrimMaterial);
        fin.position.set(2.48, 0.18, i * 0.22);
        carGroup.add(fin);
      }

      // ── SIDE MIRRORS ──
      [-0.9, 0.9].forEach(z => {
        const mirrorGroup = new THREE.Group();
        const stalkGeo = new THREE.BoxGeometry(0.15, 0.04, 0.04);
        const stalk = new THREE.Mesh(stalkGeo, bodyMaterial);
        mirrorGroup.add(stalk);

        const headGeo = new THREE.BoxGeometry(0.12, 0.08, 0.15);
        const head = new THREE.Mesh(headGeo, bodyMaterial);
        head.position.set(-0.05, 0, z > 0 ? 0.08 : -0.08);
        mirrorGroup.add(head);

        mirrorGroup.position.set(-1.5, 1.0, z);
        carGroup.add(mirrorGroup);
      });

      // ── WHEELS ──
      function createWheel() {
        const wheelGroup = new THREE.Group();

        // Tire
        const tireGeo = new THREE.TorusGeometry(0.35, 0.12, 16, 32);
        const tire = new THREE.Mesh(tireGeo, tireMaterial);
        tire.rotation.y = Math.PI / 2;
        wheelGroup.add(tire);

        // Rim face
        const rimFaceGeo = new THREE.CylinderGeometry(0.28, 0.28, 0.1, 32);
        const rimFace = new THREE.Mesh(rimFaceGeo, rimMaterial);
        rimFace.rotation.x = Math.PI / 2;
        wheelGroup.add(rimFace);

        // Rim outer ring
        const rimRingGeo = new THREE.TorusGeometry(0.3, 0.025, 8, 32);
        const rimRing = new THREE.Mesh(rimRingGeo, rimMaterial);
        rimRing.rotation.y = Math.PI / 2;
        wheelGroup.add(rimRing);

        // Spokes (aerodynamic turbine style)
        for (let i = 0; i < 7; i++) {
          const angle = (i / 7) * Math.PI * 2;
          const spokeGeo = new THREE.BoxGeometry(0.22, 0.02, 0.04);
          const spoke = new THREE.Mesh(spokeGeo, rimMaterial);
          spoke.position.set(
            0,
            Math.cos(angle) * 0.14,
            Math.sin(angle) * 0.14
          );
          spoke.rotation.x = angle;
          wheelGroup.add(spoke);
        }

        // Center cap
        const capGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.12, 16);
        const cap = new THREE.Mesh(capGeo, chromeMaterial);
        cap.rotation.x = Math.PI / 2;
        wheelGroup.add(cap);

        // BMW logo ring on center cap
        const logoRingGeo = new THREE.TorusGeometry(0.045, 0.005, 8, 16);
        const logoRing = new THREE.Mesh(logoRingGeo, chromeMaterial);
        logoRing.rotation.y = Math.PI / 2;
        logoRing.position.x = 0.065;
        wheelGroup.add(logoRing);

        // Brake disc (visible behind spokes)
        const brakeGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.02, 32);
        const brakeMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.3 });
        const brake = new THREE.Mesh(brakeGeo, brakeMat);
        brake.rotation.x = Math.PI / 2;
        brake.position.x = -0.02;
        wheelGroup.add(brake);

        // Blue brake caliper
        const caliperGeo = new THREE.BoxGeometry(0.04, 0.08, 0.06);
        const caliper = new THREE.Mesh(caliperGeo, bluAccentMaterial);
        caliper.position.set(0.01, 0.15, 0);
        wheelGroup.add(caliper);

        return wheelGroup;
      }

      // Position wheels
      const wheelPositions = [
        { x: -1.6, y: 0.35, z: 1.0 },   // front-left
        { x: -1.6, y: 0.35, z: -1.0 },  // front-right
        { x: 1.6, y: 0.35, z: 1.0 },    // rear-left
        { x: 1.6, y: 0.35, z: -1.0 }    // rear-right
      ];

      const wheels = [];
      wheelPositions.forEach((pos, i) => {
        const wheel = createWheel();
        wheel.position.set(pos.x, pos.y, pos.z);
        if (pos.z < 0) wheel.rotation.y = Math.PI; // Flip right-side wheels
        wheel.castShadow = true;
        carGroup.add(wheel);
        wheels.push(wheel);
      });

      // ── WHEEL ARCHES (fender flares) ──
      wheelPositions.forEach(pos => {
        const archGeo = new THREE.TorusGeometry(0.42, 0.06, 8, 16, Math.PI);
        const arch = new THREE.Mesh(archGeo, bodyMaterial);
        arch.position.set(pos.x, pos.y, pos.z > 0 ? 0.98 : -0.98);
        arch.rotation.y = pos.z > 0 ? 0 : Math.PI;
        arch.rotation.z = 0;
        arch.castShadow = true;
        carGroup.add(arch);
      });

      // ── ROOF RAILS (subtle) ──
      [-0.55, 0.55].forEach(z => {
        const railGeo = new THREE.BoxGeometry(1.5, 0.02, 0.02);
        const rail = new THREE.Mesh(railGeo, chromeMaterial);
        rail.position.set(-0.1, 1.72, z);
        carGroup.add(rail);
      });

      // ── CHARGING PORT ──
      const portGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.02, 16);
      const port = new THREE.Mesh(portGeo, chromeMaterial);
      port.rotation.x = Math.PI / 2;
      port.position.set(-0.8, 0.65, 1.08);
      carGroup.add(port);

      const portRingGeo = new THREE.TorusGeometry(0.05, 0.008, 8, 16);
      const portRing = new THREE.Mesh(portRingGeo, bluAccentMaterial);
      portRing.position.set(-0.8, 0.65, 1.09);
      carGroup.add(portRing);

      return { wheels };
    }

    const car = buildCar();

    // ─── LIGHTING ────────────────────────────────────────
    // Ambient
    const ambientLight = new THREE.AmbientLight(0x222233, 0.5);
    scene.add(ambientLight);

    // Key light (warm, from top-right-front)
    const keyLight = new THREE.DirectionalLight(0xfff5e6, 2.0);
    keyLight.position.set(5, 8, 3);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    keyLight.shadow.camera.near = 0.5;
    keyLight.shadow.camera.far = 25;
    keyLight.shadow.camera.left = -5;
    keyLight.shadow.camera.right = 5;
    keyLight.shadow.camera.top = 5;
    keyLight.shadow.camera.bottom = -5;
    keyLight.shadow.bias = -0.001;
    scene.add(keyLight);

    // Fill light (cool, from the left)
    const fillLight = new THREE.DirectionalLight(0xb0c4de, 0.8);
    fillLight.position.set(-5, 4, -2);
    scene.add(fillLight);

    // Rim light (from behind)
    const rimLight = new THREE.DirectionalLight(0xffffff, 1.0);
    rimLight.position.set(0, 3, -6);
    scene.add(rimLight);

    // Top light (overhead studio)
    const topLight = new THREE.DirectionalLight(0xffffff, 0.6);
    topLight.position.set(0, 10, 0);
    scene.add(topLight);

    // Ground bounce
    const bounceLight = new THREE.DirectionalLight(0x1a1a3e, 0.3);
    bounceLight.position.set(0, -2, 0);
    scene.add(bounceLight);

    // Subtle blue accent lights
    const accentLight1 = new THREE.PointLight(0x1e88e5, 0.4, 10);
    accentLight1.position.set(-3, 0.5, 0);
    scene.add(accentLight1);

    const accentLight2 = new THREE.PointLight(0x1e88e5, 0.3, 10);
    accentLight2.position.set(3, 0.5, 0);
    scene.add(accentLight2);

    // ─── ANIMATION ───────────────────────────────────────
    let autoRotate = true;
    let targetCameraPos = null;
    let targetLookAt = null;
    let animatingCamera = false;

    function animate() {
      requestAnimationFrame(animate);

      // Auto-rotate the car on turntable
      if (autoRotate && !animatingCamera) {
        carGroup.rotation.y += 0.003;
      }

      // Animate wheel rotation (subtle spin)
      car.wheels.forEach(wheel => {
        wheel.children.forEach(child => {
          if (child.geometry && child.geometry.type === 'TorusGeometry') {
            // Spin the wheel slowly when on turntable
          }
        });
      });

      // Camera transition
      if (animatingCamera && targetCameraPos) {
        camera.position.lerp(targetCameraPos, 0.04);
        controls.target.lerp(targetLookAt, 0.04);

        if (camera.position.distanceTo(targetCameraPos) < 0.05) {
          animatingCamera = false;
        }
      }

      controls.update();
      renderer.render(scene, camera);
    }

    // ─── CAMERA VIEWS ────────────────────────────────────
    const views = {
      orbit: { pos: new THREE.Vector3(6, 3, 8), target: new THREE.Vector3(0, 0.8, 0) },
      front: { pos: new THREE.Vector3(-8, 2, 0), target: new THREE.Vector3(0, 0.7, 0) },
      side: { pos: new THREE.Vector3(0, 2.5, 8), target: new THREE.Vector3(0, 0.7, 0) },
      rear: { pos: new THREE.Vector3(8, 2.5, 2), target: new THREE.Vector3(0, 0.7, 0) }
    };

    function goToView(name) {
      autoRotate = name === 'orbit';
      const view = views[name];
      targetCameraPos = view.pos.clone();
      targetLookAt = view.target.clone();
      animatingCamera = true;

      document.querySelectorAll('.btn[data-view]').forEach(b => b.classList.remove('active'));
      document.querySelector(`.btn[data-view="${name}"]`).classList.add('active');
    }

    // ─── UI EVENT HANDLERS ───────────────────────────────
    // View buttons
    document.querySelectorAll('.btn[data-view]').forEach(btn => {
      btn.addEventListener('click', () => goToView(btn.dataset.view));
    });

    // Color swatches
    document.querySelectorAll('.color-swatch').forEach(swatch => {
      swatch.addEventListener('click', () => {
        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
        swatch.classList.add('active');
        const color = parseInt(swatch.dataset.color);
        bodyMaterial.color.setHex(color);
      });
    });

    // Hide hint after first interaction
    let hintVisible = true;
    controls.addEventListener('start', () => {
      if (hintVisible) {
        document.getElementById('hint').style.opacity = '0';
        hintVisible = false;
      }
    });

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ─── START ───────────────────────────────────────────
    // Hide loader
    setTimeout(() => {
      document.getElementById('loader').classList.add('hidden');
    }, 1500);

    animate();
  </script>
</body>
</html>
